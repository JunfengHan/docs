# 前端 1000 问，快问快答

## 1.CSS 篇

### 1.1 重要概念与属性

问 ❓：BFC 是什么？有什么作用？

> 答：BFC 是**块级格式化上下文**，是**页面中可视 CSS 渲染的一部分**，可以理解为一个相对独立的布局区域。
>
> 可以解决**让浮动元素高度塌陷**、**上下 margin 折叠**等问题；

问 ❓：rem、em 与 vh 的区别？

> 答：
>
> **1rem**是等于根元素\<html\>字体大小
>
> **1em**等于父元素字体大小
>
> **1vh**等于“视口”高度的 1%；

问 ❓：如何理解 Flex（弹性） 布局？

> 答：<1> Flex 布局把布局元素分为**Flex 容器**和**Flex 元素**两部分
>
> <2>通过<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">Flex 容器</code>可以控制容器内所有<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">Flex 元素</code>在**主轴**和**交叉轴**的整体布局。
>
> <3>通过单独控制<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">Flex 元素</code>的属性可以控制单个<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">Flex 元素</code>的布局和剩余空间占用情况。
>
> [Flex 属性速查](https://www.processon.com/view/link/603dfb0d1e085353231ae05d)

问 ❓：CSS transform 属性熟悉吗？

> CSS <code style="color: #708090; background-color: #F5F5F5; font-size: 18px">transform</code> 属性允许你**旋转**，**缩放**，**倾斜**或**平移**给定元素。
>
> translate(水平垂直方向**平移**)、scale(水平垂直方向**缩放**)、skew(水平垂直方向**倾斜**)、rotate(绕元素中心旋转，如：90deg)、scale(绕中心缩放，如：0.5 为缩小为一半)
>
> **matrix(矩阵)**方法可以实现任何上面的组合效果；
>
> 注意 ⚠️：只能转化 {display: block;} 的元素。

问 ❓：了解什么是<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">包含块</code>吗？

> 答：多说情况下，包含块是这个元素**最近的祖先块元素**的**内容区**，元素的尺寸、位置百分比计算是根据**包含块**来确定的。
>
> 主要知识点：
>
> <1>position 属性为 static | relative | sticky 时，包含块一般由**它的最近的祖先块元素**的**内容边缘**组成
>
> <2>position 属性为 absolute,包含块就是由它的**最近的 position 不是 static 的祖先元素**的**内容边缘**组成
>
> <3>position 属性是 fixed，包含块为**可视视口**

### 1.2 水平垂直居中

问 ❓：已知父元素宽高，子元素宽高**未知**，如何实现子元素“水平垂直居中”？（腾讯一面原题）

> 答：
>
> 1.Flex 布局，给**父元素**设置：

```css
 {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

> 2.绝对定位 + transform 偏移， 如：**父元素**：{position: relative;},**子元素**如下，

```css
 {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

> 3.基于视口单位：**vh**(适用于基于整个视口的居中,如，"弹窗")

```css
 {
  margin: 50vh auto 0;
  transform: translate(-50%, -50%);
}
```

问 ❓：已知父元素宽高，子元素宽高**也已知**，如何实现子元素“水平垂直居中”？

> 答：上面的方法对**子元素宽度已知**都是有效的，已知**子元素**宽高的话还可以使用下面的方法。
>
> 1.绝对定位 + margin 偏移，给**父元素**：{position: relative;},**子元素**设置如下：

```css
 {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 6em;
  height: 8em;
  margin-top: -4em;
  margin-left: -3em;
}
```

或者省略“margin-top”和“margin-left”，使用<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">calc()</code>直接计算出前居中位置：

```css
 {
  position: absolute;
  left: calc(50% - 3em);
  top: calc(50% - 4em);
  width: 6em;
  height: 8em;
}
```

---

**总结**：

- Flex 元素天生适合"水平、垂直居中"布局；
- 其他方案主要分为两步：
  - 1. 先把子元素的“左上顶点”移动到父元素的中心点
    - 绝对定位方案
  - 2. 偏移子元素
    - **子元素宽高未知**：可以用**transform**偏移
    - **子元素宽高已知**：可以用**负 margin**偏移

---

问 ❓：如何实现一个“垂直水平居中”的弹窗？

> 答：一般有 3 种方案：
>
> <1>固定定位（fixed）**遮罩层**，绝对定位**弹窗**

_HTML 元素_

```html
<!-- 遮罩层 -->
<div class="bg">
  <!-- 弹窗 -->
  <div class="pop"></div>
</div>
```

_方案 1：绝对定位 + transform_

```css
/* 遮罩层 */
.bg {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.3);
}
/* 弹窗 */
.pop {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  /* 默认宽高，可修改 */
  width: 500px;
  height: 500px;
}
```

_方案 2:使用视口单位 vh + transform_

```css
.pop {
  margin: 50vh auto 0;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border: 1px solid red;
}
```

### 1.3 清除浮动

问 ❓：如何清除浮动？

> 方案 1：叫做**clearfix**,即：给 container 添加**伪元素** ，并给其**clear：both;**

```css
#container::after {
  content: "";
  display: block;
  clear: both;
}
```

> 方案 2：触发父元素形成**BFC**

```css
#container {
  overflow: auto;
  /* 或 */
  display: flow-root;
  /* 或 */
  display: inline-block;
}
```

## 2. JS 篇

### 2.1 重要概念及 API 等

问 ❓：var、let、const 有什么区别？（腾讯一面原题）

> 答：let 和 const 在块级作用域内有效，let 和 const 的区别是 const 定义常量一样，定义后不可以重新赋值。
>
> 在代码执行执行的编译时，var 定义的变量在赋值之前为 _undefined_，let 和 const 在赋值之前为*uninitialized*；
>
> let 和 const 定义的变量在赋值前不能访问，会**未定义**报错。

问 ❓：for...in 与 for...of 区别？

> <code style="color: #708090; background-color: #F5F5F5; font-size: 18px">for...in</code>遍历对象除*Symbol*以外的**可枚举**属性；
>
> <code style="color: #708090; background-color: #F5F5F5; font-size: 18px">for...of</code>语句在**可迭代对象**上创建一个迭代循环；

问 ❓：for 与 forEach 区别？

问 ❓：如何跳出 for 或 forEach 循环？

问 ❓：Map 与 Object 区别？

### 2.2 异步与 Event Loop

问 ❓：下面代码打印结果是什么？为什么？（腾讯一面原题）

```js
Promise.resolve().then(() => {
  console.log("P1");
  setTimeout(() => {
    console.log("S2");
  }, 0);
});

setTimeout(() => {
  console.log("S1");
  Promise.resolve().then(() => {
    console.log("P2");
  });
}, 0);

console.log(1);
```

> 答：1, P1，S1，P2，S2。
>
> 1. 整个代码片段是个宏任务，进行第一个**事件循环**，开始执行里面代码，往<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">微任务队列</code>添加了一个**微任务**（.then()里的回调函数，我们叫它 Promise1）；同时，往<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">宏任务队列</code>添加了一个**宏任务**（下方 setTimeout 里的回调，我们叫它 Time1）
>
> 2. 执行到 console.log(1)，会直接打印 1；
>
> 3. 然后，依次执行<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">微任务队列</code>里所有**微任务**，微任务只有一个 Promise1，所以会打印 "P1"；同时，添加一个新的**宏任务**（setTimeout 的回调，我们叫它 Time2）到宏任务队列
>
> 4. 执行完微任务 Promise1 后，<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">宏任务队列</code>上有两个**宏任务**，分别是 Time1 和 Time2; 先执行 Time 1，会打印 "S1";同时，添加了一个**微任务**（我们叫他 Promise2）到<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">微任务队列</code>；
>
> 5. 此时，<code style="color: #708090; background-color: #F5F5F5; font-size: 18px">微任务队列</code>有一个 Promise2；宏任务队列还有一个没执行的 Time2;先执行 Promise2，所以会打印“P2”;
>
> 6. 最后，只剩下 <code style="color: #708090; background-color: #F5F5F5; font-size: 18px">宏任务队列</code>上的 Time2，所以，打印“S2”.

升级版：

```js
Promise.resolve()
  .then(() => {
    console.log("P1");
    setTimeout(() => {
      console.log("S2");
    }, 0);
  })
  .then(() => {
    console.log(3);
    setTimeout(() => {
      console.log("S3");
    }, 0);
  });

setTimeout(() => {
  console.log("S1");
  Promise.resolve().then(() => {
    console.log("P2");
  });
}, 0);

console.log(1);
```

> 打印：1，P1，3，S1，P2，S2，S3
>
> 简述：先执行同步，分别往**微任务队列**和**宏任务队列**各添加一个任务，打印 1 ，同步执行结束 --> 然后，开始下一轮事件循环，执行**微任务**，所以打印 P2,然后添加 S2 到**宏任务队列**，继续执行微任务，打印 3，添加 S3 到**宏任务队列** --> 然后依次执行，S1，S2,S3。因为执行 S1 时，新增了微任务 P2,所以，打印顺序为 S1,P2,S2,S3。

## 3. React 篇

### 3.1 Hook

问 ❓：为什么需要 Hooks?或者说 Hooks 解决了什么问题？

> 答：<1> 组件之间难以复用状态逻辑(例如只能使用高阶组件做登陆状态判断)
>
> <2>复杂的组件变得难以理解(如：componentDidMount 集成了很多互不相关的副作用)
>
> <3>JS 的 Class 和 this 不好理解，特别是对于非前端开发者

问 ❓：[React Hooks 是什么](https://zh-hans.reactjs.org/docs/hooks-overview.html#but-what-is-a-hook)？

> 每个 Hook 是一个特殊的函数，可以在函数组件中使用，它可以让你“钩入” **React state** 及**生命周期**等特性。
>
> 我们不需要特殊的 API 来读取 Hook —— 它已经保存在函数作用域中。
>
> Hook 使用了 JavaScript 的闭包机制。

问 ❓：使用 Hook 有哪些限制？如何避免？

> 答：只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。
>
> 使用 Lint 工具库， “eslint-plugin-react-hooks” 完成自动检查。

问 ❓：什么是副作用？有哪些常见的副作用？

> 答：**副作用**指和渲染无关的任何操作。如：数据请求、手动修改 DOM。

问 ❓：生命周期方法要如何对应到 Hook？(ps:这个 react 官方文档的问题)（腾讯一面原题）

> useEffect 可以看作是 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。
>
> React.memo 等效于 PureComponent, 但它只比较 props，不比较 state.

如：

```js
const Button = React.memo((props) => {
  // 你的组件
});
```

---

问 ❓：setState 是同步还是异步？

> 答：React 控制的 setState 调用是异步更新，非 React 控制的调用是同步，如：setTimeout 的回调中。

问 ❓：如何使用 useEffect，让它只更新一次？（腾讯一面原题）

> 答：useEffect 默认**第一次渲染之后**和**每次更新之后**都会执行；
>
> 可以给它传递第二个参数“[]”，控制它只在**第一次挂载时**执行；
>
> 可以给他传递第二个参数“\[stateA, prop1\]”，则 stateA 或 prop1 发生变化后执行；

问 ❓：[useEffect 做了什么？有什么用？](https://zh-hans.reactjs.org/docs/hooks-effect.html#example-using-hooks)

> 答：告诉 React 组件需要在渲染后执行某些操作。
>
> 同一个函数组件中可以多次调用 useEffect，实现**关注点分离**。

问 ❓：React 何时清除 Effect？

> React 会在组件卸载的时候执行清除操作。
>
> Effect 的清除阶段在每次重新渲染时都会执行，防止因为更新导致 bug。

问 ❓：如何手动清除 Effect ?

> 答：让 useEffect 的回调函数返回一个**清除函数**。

如：

```js
function Fn(props) {
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Effect清除函数，React 将会在执行清除操作时调用它
    // 这样，移除订阅和上面的添加订阅逻辑放在一起了
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
}
```

问 ❓：使用 useEffect 要注意什么？（腾讯一面原题）

> 答：

问 ❓：react 如何使组件的状态复用？

> 1. [render props 传递 state](https://shushuo.me/#/react/react_hooks?id=_11-%e4%bd%bf%e7%94%a8-render-props-%e4%bc%a0%e9%80%92-state)
>
> 2. [高阶函数](https://shushuo.me/#/react/react_hooks?id=_12-%e4%bd%bf%e7%94%a8-%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%ef%bc%88hoc%ef%bc%89%e4%bc%a0%e9%80%92-state)
>
> 3. 状态管理库，redux 等

### 3.1 React Router

问 ❓：React Router 原理是什么？

> Route 内的组件当作自己的子组件进行管理，通过监听 hashChange 和 popstate 事件来改变组件的显示隐藏。

### 3.2 Redux

问 ❓：Redux 的原理是什么？

## 4. Node 篇

问 ❓：Koa 和 Express 框架有什么不同？

问 ❓：Nest 框架有什么特点？

问 ❓：Nest 相比于 Koa 和 Express 有什么不同？（腾讯一面真题）

## 5. 网络篇

问 ❓：HTTP 与 HTTPS 区别？

> 答：

问 ❓：GET 与 POST 区别？

> 答：

答：了解 TCP 的三次握手与四次挥手吗？

>

问 ❓：知道哪些常见的状态码？

>

## 6. Webpack 篇

问 ❓：Webpack 的原理是什么？

问 ❓：Webpack 与 Grunt、Rollup 有什么区别？你会怎么选？

问 ❓：Webpack 可以做哪些优化？

## 7. Babel 篇

## 8. NPM 篇

## 9. 算法篇

问 ❓：排序算法知道哪些？时间复杂度如何？

问 ❓：手写一个快排？
